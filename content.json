[{"title":"跨域方法总结（一），JSONP","date":"2017-01-15T02:26:03.000Z","path":"2017/01/15/jsonp/","text":"前言博主博客：Stillwater的博客知乎专栏：前端汪汪本文为作者原创转载请注明出处：http://hiztx.top/2017/01/15/jsonp/ &emsp;&emsp;本文介绍了什么是跨域，为什么要跨域，以及跨域的一种常用方法JSONP的原理。 一、什么是跨域？为什么要跨域？什么是跨域？&emsp;&emsp;既然是跨域，那么肯定是从一个域到另一个域。那么首先要知道满足什么条件才是同一个域。如果两个页面拥有相同的协议，端口和域名，那么这两个页面就属于同一个源（origin），JavaScript允许这种同源页面的数据互相通信。例如你要访问百度首页。 https://www.baidu.comhttps是协议https协议的默认端口为443（不显示）www.baidu.com为域名 注：一般端口默认为不显示，但是你可以尝试输入以下网址，发现无法访问。因为80端口默认为http协议端口。 https://www.baidu.com:80 &emsp;&emsp;现在知道了什么是同一个域，那么就可以解释什么是跨域。只要协议、域名、端口有任何一个不同，都被当作是不同的域，之间的请求就是跨域操作。 为什么要跨域？&emsp;&emsp;相信很多人都听过，同源策略。出于安全考虑，浏览器对JavaScript的很多功能进行了限制，其中一条就是，不同域之间不予许进行数据通信。虽然补全了安全漏洞，但是这个限制给前端开发带来了许多不便。例如： zhidao.baidu.comwenku.baidu.com &emsp;&emsp;百度知道和百度文库大家都不陌生，都是百度开发的web服务。虽然这两个都是李彦宏的，但是现在告诉他，由于你这两个域名的三级域名不一样，不允许相互数据通信。你说不行就不行？于是就有像李彦宏这样的大牛搞出一些黑科技专门用来跨域通信。JSONP就是其中之一。 注：1.com为顶级域名，baidu为二级域名，zhidao/wenku为三级域名2.跨域并非浏览器限制了发起跨站请求，而是跨站请求可以正常发起，但返回结果被浏览器拦截了。 二、什么是JSONP？顾名思义： JSONP = JSON + P &emsp;&emsp;JSONP（JSON with Padding），JSON是一种轻量级的数据交换格式。而Padding在这里可以翻译为填充。那么JSONP的意思就是，填充的JSON。是数据格式JSON的一种使用模式，可以让网页从别的网域要数据。 三、JSONP原理 JSONP的核心原理就是，HTML的script标签可以加载并执行其他域JS文件。 &emsp;&emsp;这里区分两个概念，当我们用浏览器打开百度知道首页的时候，是向百度知道服务器发送了一个Https请求，获取到百度知道首页的index.html。如果在这个index.html里面用XMLHttpRequest对象向百度文库服务器发送Https请求，那么就属于跨域，是不允许的。但是如果在百度知道首页的index.html中加入一个script标签，其src属性指向百度文库中的一个.json文件，是允许的。&emsp;&emsp;为了理解这种模式的原理，先想像有一个回传JSON文件的URL，而JavaScript 程序可以用XMLHttpRequest跟这个URL要数据。假设我们的URL是 http://server2.example.com/RetrieveUser?UserId=xxx 。假设小明的UserId 是1823，且当浏览器通过URL传小明的UserId，也就是抓取 http://server2.example.com/RetrieveUser?UserId=1823 。得到：1234&#123;\"Name\": \"小明\", \"Id\": 1823, \"Rank\": 7&#125; &emsp;&emsp;这个JSON数据可能是依据传过去URL的查询参数动态产生的。这个时候，把 script元素的src属性设成一个回传JSON的URL是可以想像的，这也代表从HTML页面通过script元素抓取JSON是可能的。然而，一份JSON文件并不是一个JavaScript程序。为了让浏览器可以在 script元素运行，从src里URL回传的必须是可运行的JavaScript。在JSONP的使用模式里，该URL回传的是由函数调用包起来的动态生成JSON，这就是JSONP的“填充（padding）”或是“前辍（prefix）”的由来。123&lt;script type=\"text/javascript\" src=\"http://server2.example.com/RetrieveUser?UserId=1823&amp;jsonp=parseResponse\"&gt; &lt;/script&gt; &emsp;&emsp;服务器会在传给浏览器前将JSON数据填充到回调函数（parseResponse）中。浏览器得到的回应已不是单纯的数据叙述而是一个脚本。在本例中，浏览器得到的是： 12345678&#123; parseResponse( &#123; \"Name\": \"小明\", \"Id\": 1823, \"Rank\": 7 &#125;)&#125; &emsp;&emsp;也就是说，一般情况下浏览器向服务器发送请求得到的都是数据（文本，XML，JSON），但是当采用JSONP技术时候，浏览器向跨域服务器发送请求，得到的是回调函数包住的JSON。此处JSON作为参数传入回调函数，然后再返回给浏览器。 再举个例子：浏览器端：12345678910111213&lt;body&gt; &lt;!--声明jsonpcallback回调函数，参数为json数据--&gt; &lt;script type=\"text/javascript\"&gt; function jsonpcallback(json) &#123; console.log(json); &#125; &lt;!--创建一个&lt;script&gt;标签，设置src为一个跨域的URL，并指定回调函数为jsonpcallback--&gt; var s = document.createElement('script'); s.src=\"http://localhost:8080/test.php?callback=jsonpcallback\"; document.body.appendChild(s); &lt;/script&gt;&lt;/body&gt; 服务器端：1234567&lt;?php $jsondata = '&#123; \"name\": \"Stillwater\", \"age\": 12 &#125;'; echo $_GET['callback'].'('.$jsondata.')';?&gt; 服务器返回浏览器：123456jsonpcallback( &#123; \"name\": \"Stillwater\", \"age\": 12 &#125; ) &emsp;&emsp;在这个例子中，浏览器向服务器发出跨域请求（”http://localhost:8080/test.php?callback=jsonpcallback&quot;）。请求一个json数据, {“name”: “Stillwater”,”age”: 12} 。并且告诉了服务器回调函数的名字。服务器接收到请求后，就将json数据作为参数填充到回调函数中，返回给浏览器。最终返回一个填充了json数据的回调函数。 四、总结 首先在客户端注册一个callback，然后把callback的名字传给服务器。 服务器先生成json数据。然后以Javascript语法的方式，生成一个function ，function名字就是传递上来的参数callback。 最后将json数据直接以入参的方式，放置到function中，这样就生成了一段 js 语法的文档，返回给客户端。 客户端浏览器，解析script标签，并执行返回的Javascript 文档，此时数据作为参数，传入到了客户端预先定义好的callback 函数里。（动态执行回调函数） 参考链接： https://zh.wikipedia.org/wiki/JSONPhttp://www.cnblogs.com/zichi/p/4593047.htmlhttp://tech.jandou.com/cross-domain.htmlhttps://segmentfault.com/a/1190000003642057http://wearejq.github.io/2015/07/18/kuayu/","tags":[]},{"title":"AJAX总结（三），XMLHttpRequest对象","date":"2017-01-13T08:33:10.000Z","path":"2017/01/13/ajax-3/","text":"前言博主博客：Stillwater的博客知乎专栏：前端汪汪本文为作者原创转载请注明出处：http://hiztx.top/2017/01/13/ajax-3/ &emsp;&emsp;这篇文章介绍了XMLHttpRequest对象相关知识。包括：XMLHttpRequest对象的本质，Http请求和Http响应。 一、XMLHttpRequest对象的本质&emsp;&emsp;为了更好的理解XMLHttpRequest对象的本质，我们将其分成三部分来理解。顾名思义， XMLHttpRequest = XML + Http + Request 。 什么是XML？&emsp;&emsp;XML设计用来传送及携带数据信息，不用来表现或展示数据，HTML语言则用来表现数据，所以XML用途的焦点是它说明数据是什么，以及携带数据信息。XML被广泛用来作为跨平台之间交互数据的形式，主要针对数据的内容。&emsp;&emsp;例如，XML定义结构、存储信息、传送信息。下例为小张发送给大元的便条，存储为XML。这XML文档仅是纯粹的信息标签，这些标签意义的展开依赖于应用它的程序。1234567&lt;?xml version=\"1.0\"?&gt;&lt;小纸条&gt; &lt;收件人&gt;大元&lt;/收件人&gt; &lt;發件人&gt;小張&lt;/發件人&gt; &lt;主題&gt;問候&lt;/主題&gt; &lt;具體內容&gt;早啊，飯吃了沒？ &lt;/具體內容&gt;&lt;/小纸条&gt; 什么是Http？&emsp;&emsp;超文本传输协议（英文：HyperText Transfer Protocol，缩写：HTTP）是互联网上应用最为广泛的一种网络协议。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。本文后面会详细介绍AJAX技术相关的Http知识。 什么是Request？&emsp;&emsp;Request翻译为请求，这个大家都知道。但是很多人会误解，只有用浏览器（Chrome，Safari，IE），我们才能向服务器发送Http请求。这是不对的。我们换个角度，从服务器的角度思考。当服务器收到全世界各地发来的Http请求的时候，它并不知道屏幕的对面是谁，有可能是正在网上冲浪的你，也有可能仅仅是一只网络爬虫，甚至有可能就是我们编写的AJAX程序中的XMLHttpRequest对象而已。 &emsp;&emsp;回到我们的问题，XMLHttpRequest对象的本质是什么？ 是一个可以发送Http请求，处理Http响应，与服务器之间进行异步交换数据的对象，其核心是Http。 &emsp;&emsp;所以要想深入理解XMLHttpRequest对象，那就要学习一些Http的知识了。请往下看。 二、Http请求一个Http请求由4部分组成： Http请求方法（GET、POST、DELETE、PUT） 正在请求的URL（/home/index.html） 请求头（可选） 请求主体（可选） 创建XMLHttpRequest对象之后，发起Http请求的下一步是调用XMLHttpRequest对象的open()方法去指定这个请求的两个必要部分：请求方法和URL。1request.open(\"GET\",/home/index.html);//请求方法：GET，URL：/home/index.html open()的第一个参数指定Http请求方法，通常用大写字母来匹配Http协议。open()的第二个参数是URL，是请求的主要内容。如果有请求头的话，请求进程的下一个步骤是设置它。例如，POST请求需要“Content-type”。1request.setRequestHeader(\"Content-type\",\"text/plain\"); 使用XMLHttpRequest发起Http请求的最后一步是指定请求主体（可选）并向服务器发送它。使用send()方法像如下这样做：1request.send(null); GET请求没有主体，所以应该传递null或省略这个参数。 Http请求的各部分有指定顺序：请求方法和URL首先到达，然后是请求头，最后是请求主体。调用XMLHttpRequest方法的顺序必须匹配Http请求的顺序。例如：setRequestHeader()方法的调用必须在open()方法之后，send()方法之前，否则将抛出异常。 例：用POST方法发送纯文本给服务器123456function postMessage(msg)&#123; var request = new XMLHttpRequest(); //创建新请求 request.open(\"POST\",\"/log.php\"); //用POST向服务器端发送脚本 request.setRequestHeader(\"Content-type\",\"text/plain;charset=UTF-8\"); //请求头设置 request.send(msg); //把msg作为请求主体发送 &#125; //由于没有指定响应函数，所以我们将忽略任何响应 三、Http响应服务器返回的Http响应包含3部分： 数字和文字组成的状态码，用来显示请求的成功和失败 响应头 响应主体 我们可以通过XMLHttpRequest对象的属性和方法来获取上述响应包括的三个部分。 status和statusText属性以数字和文本的形式返回Http状态码。 使用getResponseHeader()和getAllResponseHeaders()能查询响应头。 响应主体可以从responseText属性中得到文本形式的，从responseXML属性中得到Document形式的。 readyState是一个整数，指定了Http请求的状态。 表：XMLHttpRequest的readyState值 | 常量 | 值 | 含义 | | :—-: | :—-: | :—-: | | UNSENT | 0 | open()尚未调用 | | OPENED | 1 | open()已经调用 | | HEADERS_RECEIVED | 2 |接收到头信息 | | LOADING | 3 | 接收到响应主体 | | DONE | 4 | 响应完成 | 为了监听readystatechange事件，请把事件处理函数设置为XMLHttpRequest对象的onreadystatechange属性。 例：获取Http响应的onreadystatechange123456789101112131415//发出一个Http GET请求以获得指定URL的内容//当响应成功到达，验证它是否是纯文本//如果是，把它传递给指定回调函数function getText(url,callback)&#123; var request = new XMLHttpRequest(); //创建新请求 request.open(\"GET\",url); //指定待获取的URL request.onreadystatechange = funciton()&#123; //定义事件处理函数 if (request.readyState===4&amp;&amp;request.status===200&#123; //如果请求完成，则它是成功的 var type = request.getResponseHeader(\"Content-Type\"); if(type.match(/^text/)) //确保响应是文本 callback(request.responseText); //把它传递给回调函数 &#125; &#125;; request.send(null) //立即发送请求&#125; 四、总结本文介绍了XMLHttpRequest对象的本质是一个可以发送Http请求，处理Http响应，与服务器之间进行异步交换数据的对象，其核心是Http。然后介绍了Http请求和响应包括的具体内容。Http请求包括：方法，URL，请求头，请求主体。Http响应包：状态码，响应头和响应主体。 参考文献：1维基百科2JavaScript权威指南","tags":[]},{"title":"AJAX总结（二），手写AJAX","date":"2017-01-12T08:16:17.000Z","path":"2017/01/12/ajax-2/","text":"前言博主博客：Stillwater的博客知乎专栏：前端汪汪本文为作者原创转载请注明出处：http://hiztx.top/2017/01/12/ajax-2/ &emsp;&emsp;在前端面试的时候经常会有如下情景。AJAX会吗？能不能手写个AJAX？第一个问题可以参见我的另一篇博客，AJAX总结（一），AJAX概述。这篇博文我们来回答第二个问题，手写AJAX。 一、手写AJAX的步骤&emsp;&emsp;手写AJAX并没有一个固定的标准的答案，但是AJAX的关键步骤就那么几步，我会先用文字介绍关键步骤，然后给出两个版本的手写AJAX的代码及注释。帮助大家很好地理解和记忆。 创建XMLHttpRequest对象 指定响应函数 打开连接（指定请求） 发送请求 创建响应函数 注：第三步是使用XMLHttpRequest对象的open（）方法，字面意思open是打开的意思，即打开连接。但是准确的说应该是指定Http请求。因为浏览器在使用AJAX技术与服务通信时，发送的是Http请求，那么就要指定Http的请求方法，url等信息。 二、参考代码（W3C）1234567891011121314151617181920212223242526272829303132333435363738var xmlhttp=null;//声明一个变量，用来实例化XMLHttpRequest对象if (window.XMLHttpRequest) &#123; xmlhttp=new XMLHttpRequest();// 新版本的浏览器可以直接创建XMLHttpRequest对象 &#125; else if (window.ActiveXObject) &#123; xmlhttp=new ActiveXObject(\"Microsoft.XMLHTTP\");// IE5或IE6没有XMLHttpRequest对象，而是用的ActiveXObject对象 &#125; if (xmlhttp!=null) &#123; xmlhttp.onreadystatechange=state_Change;//指定响应函数为state_Change xmlhttp.open(\"GET\",\"/example/xdom/note.xml\",true);//指定请求，这里要访问在/example/xdom路径下的note.xml文件，true代表的使用的是异步请求 xmlhttp.send(null);//发送请求 &#125; else &#123; alert(\"Your browser does not support XMLHTTP.\"); &#125;//创建具体的响应函数state_Changefunction state_Change()&#123;if (xmlhttp.readyState==4) &#123; if (xmlhttp.status==200) &#123; // 这里应该是函数具体的逻辑 &#125; else &#123; alert(\"Problem retrieving XML data\"); &#125; &#125;&#125; 创建XMLHttpRequest对象 （1-10行代码） 指定响应函数（第15行代码） 打开连接（指定请求）（第16行代码） 发送请求（第18行代码） 创建响应函数（25-38行代码） &emsp;&emsp;这个是W3C上讲解AJAX的代码，比较权威，我做了一些注释，方便大家理解。面试的时候写这段代码应该是没有问题的。W3C原文链接 三、参考代码（MDN）123456789101112131415161718192021222324252627282930313233343536373839&lt;!--html部分，创建一个按钮控件--&gt;&lt;span id=\"ajaxButton\" style=\"cursor: pointer; text-decoration: underline\"&gt; Make a request&lt;/span&gt;&lt;script type=\"text/javascript\"&gt;(function() &#123; var httpRequest;//声明一个变量，用来实例化XMLHttpRequest对象 document.getElementById(\"ajaxButton\").onclick = function() &#123; makeRequest('test.html'); &#125;; //这里将AJAX操作封装在makeRequest函数中，函数的参数为要请求的url，即根目录下的test.html文件。 function makeRequest(url) &#123; httpRequest = new XMLHttpRequest();//创建XMLHttpRequest对象 if (!httpRequest) &#123; alert('Giving up :( Cannot create an XMLHTTP instance'); return false; &#125; httpRequest.onreadystatechange = alertContents;//指定响应函数为alertContents httpRequest.open('GET', url); //指定请求，方法为GET，url为上面的test.html httpRequest.send();//发送请求 &#125; //创建响应函数alertContents function alertContents() &#123; if (httpRequest.readyState === XMLHttpRequest.DONE) &#123; if (httpRequest.status === 200) &#123; alert(httpRequest.responseText); &#125; else &#123; alert('There was a problem with the request.'); &#125; &#125; &#125;&#125;)();//这是一个立即执行函数&lt;/script&gt; 创建XMLHttpRequest对象 （第13行代码） 指定响应函数（第19行代码） 打开连接（指定请求）（第21行代码） 发送请求（第23行代码） 创建响应函数（29-37行代码） &emsp;&emsp;这个是MDN上讲解AJAX的代码，我做了一些注释，方便大家理解。MDN原文链接 四、总结&emsp;&emsp;这篇文章讲解了如何较为规范的手写AJAX，下篇文章我会具体介绍XMLHttpRequest对象的有关知识以及AJAX相关的Http请求的知识。","tags":[]},{"title":"AJAX总结（一），AJAX概述","date":"2017-01-11T09:46:39.000Z","path":"2017/01/11/ajax-1/","text":"前言博主博客：Stillwater的博客知乎专栏：前端汪汪本文为作者原创转载请注明出处：http://hiztx.top/2017/01/11/ajax-1/ &emsp;&emsp;介绍了什么是AJAX？为什么要用AJAX？以及AJAX有什么优缺点。 一、什么是AJAX？AJAX即“Asynchronous JavaScript and XML”（异步的JavaScript与XML技术），指的是一套综合了多项技术的浏览器端网页开发技术。是一种用来创建交互式网页应用的网页开发技术。之所以说AJAX是一项综合技术，是因为AJAX包含了以下技术： 基于HTML和CSS进行表示； 使用 DOM进行动态显示及交互； 使用 XML 和 JSON 进行数据交换及相关操作； 使用 XMLHttpRequest 进行异步数据查询、检索； 使用 JavaScript 将所有的东西绑定在一起。 注：asynchronous 异步的英 [eɪˈsɪŋkrənəs] 美 [e’sɪŋkrənəs] 二、为什么要用AJAX？传统Web应用存在的问题 传统的Web应用提交表单时会向网页服务器发送一个请求。服务器接收并处理传来的表单，然后送回一个新的网页。但这个做法浪费了许多带宽，因为在前后两个页面中的大部分HTML码往往是相同的。 由于每次应用的沟通都需要向服务器发送请求，应用的回应时间依赖于服务器的回应时间。这导致了用户界面的回应比本机应用慢得多。即同步请求，浏览器需要等待服务器处理请求，导致了浏览器端的阻塞。AJAX的出现解决的问题 AJAX应用可以仅向服务器发送并取回必须的数据，并在客户端采用JavaScript处理来自服务器的回应。因为在服务器和浏览器之间交换的数据大量减少（大约只有原来的5%）,服务器回应更快了。局部刷新。 AJAX采用异步模式，通过XMLHttpRequest对象（下篇博客具体介绍），发送给服务器请求以后，不用等待服务器的处理结果，用户可以继续进行操作。非阻塞的方式提升了用户体验。 总的来说就好像，浏览器大哥有一书包的好东西，但是他只想给服务器大哥其中一个好东西。传统Web应用处理方法是，浏览器大哥直接把书包给服务器大哥，他等服务器大哥自己找完以后，才能拿回自己的书包，继续干别的事情。AJAX的处理方法是，浏览器大哥找了个叫XMLHttpRequest的小弟来做这件事。小弟先从书包里找出来那个东西，然后再给服务器大哥。服务器拿到东西以后处理了一下再把东西还给XMLHttpRequest小弟。这期间浏览器大哥爱干嘛干嘛。 三、AJAX的优缺点优点： 能在不更新整个页面的前提下维护数据。这使得Web应用程序更为迅捷地回应用户动作，并避免了在网络上发送那些没有改变的信息。 通过异步模式，不阻塞用户，从而提升了用户体验。 AJAX不需要任何浏览器插件，但需要用户允许JavaScript在浏览器上执行。 AJAX引擎在客户端运行，承担了一部分本来由服务器承担的工作，从而减少了大用户量下的服务器负载。 缺点： 破坏浏览器的后退与加入收藏书签功能。在用AJAX动态更新页面的情况下，用户无法回到前一个页面状态，这是因为浏览器仅能记下历史记录中的静态页面。 AJAX如果使用GET方法，会暴露了与服务器交互的细节。 对搜索引擎的支持比较弱。通过AJAX动态更新的页面可能无法被搜索引擎搜到。","tags":[{"name":"JavaScript AJAX 前端 面试","slug":"JavaScript-AJAX-前端-面试","permalink":"http://yoursite.com/tags/JavaScript-AJAX-前端-面试/"}]},{"title":"<a>标签，伪类","date":"2016-12-17T04:36:35.000Z","path":"2016/12/17/a-伪类/","text":"本文为作者原创，转载请注明出处，http://hiztx.top 一、&lt;a&gt;标签常用的伪类概述1234a:link&#123;color:blue&#125; a:visited&#123;color:red&#125;a:hover&#123;color:green&#125;a:active&#123;color:purple&#125; link 当有链接，且该链接未被访问过时，此伪类处于激活状态。 vistied 某个链接已经被访问过时，此伪类处于激活状态。 hover 鼠标悬停在某个链接上时，此伪类处于激活状态，直到鼠标移开链接。 active 用鼠标点击链接时，此伪类激活。注意，鼠标点击后不松开，此伪类一直激活，直到松开鼠标。 二、&lt;a&gt;标签伪类书写顺序详解为什么要考虑伪类的书写顺序？ 第一，CSS（Cascading Style Sheets）全称翻译为层叠样式表。有时候多条规则会定义元素的同一个属性，这时该怎么办呢？CSS用层叠的原则来考虑样式声明，从而判断相互冲突的规则中哪个规则应该起作用。首先，你编写的样式如果与浏览器的默认样式冲突，均以你编写的样式为准。在此基础上，CSS用层叠的原则来考虑特殊性（specificity）、顺序（order）和重要性（importance），从而判断相互冲突的规则中哪个规则应该起作用。不要受这些术语的影响，你只要去试，就能明白CSS决定该应用哪些样式以及何时应用这些样式的方式。[^1] 第二，由于&lt;a&gt;标签的这四个伪类的特殊性是一样的，所以当某个链接处于的状态同时激活多个伪类时，那么伪类的书写顺序就起到了关键作用，从而影响最终的显示效果。这就是为什么我们要考虑伪类的书写顺序。哪些伪类会同时激活并影响显示效果？ 第一，其实:link和:visited两个伪类之间顺序无所谓。因为它俩不可能同时触发，即在未访问的同时访问过。此处注意，有人将:link理解成只要某元素有链接存在，就会激活，这是错误的。当链接被访问过以后，:link就不再激活。我们做个试验。1234a:visited&#123;color:red&#125; a:hover&#123;color:green&#125;a:active&#123;color:purple&#125;a:link&#123;color:blue&#125; 我们把:link放在最后，开始时链接未访问，无论是我鼠标悬浮还是点击，颜色都不会改变，都是蓝色。当我第一次点击鼠标并松开后，颜色变成红色。然后再悬浮就会变成绿色，再点击，就会变成紫色，再松开就恢复成红色。蓝色不会再出现。此时链接依然存在，只是已经被访问过，所以:link伪类不再激活。 第二，从用户习惯角度考虑，无论链接访问或未访问过，都希望当鼠标悬浮在链接上时能够产生颜色变化，并且，无论链接访问或未访问过，产生的颜色变化应该是一样的。所以应该把:hover放在:link和:visited后面1234a:link&#123;color:blue&#125; a:visited&#123;color:red&#125;a:hover&#123;color:green&#125; 第三，从用户习惯角度考虑，无论链接访问或未访问过，都希望当鼠标点击链接时能够产生颜色变化，并且，无论链接访问或未访问过，产生的颜色变化应该是一样的。所以应该把:active放在:link和:visited后面1234a:link&#123;color:blue&#125; a:visited&#123;color:red&#125;a:active&#123;color:purple&#125; 第四，顺序上，总是先将鼠标悬浮在链接上，然后才能够进行点击操作，预期效果是悬浮时产生颜色变化，点击鼠标时产生另一种颜色变化。若把hover放在active后面，当点击链接一瞬，实际你在激活active状态的同时触发了hover伪类,hover在后面覆盖了active的颜色，所以无法看到active的颜色。故hover在active之前。[^2]1234a:link&#123;color:blue&#125; a:visited&#123;color:red&#125;a:hover&#123;color:green&#125;a:active&#123;color:purple&#125; 记住顺序的口诀：“LoVe，HA” [^1]: HTML5与CSS3基础教程（第8版）第七章第四节，[美] Elizabeth Castro Bruce Hyslop 著，望以文 译。 [^2]: 引用自 &lt;a&gt;链接的四个伪类顺序。","tags":[{"name":"CSS 前端 面试","slug":"CSS-前端-面试","permalink":"http://yoursite.com/tags/CSS-前端-面试/"}]},{"title":"Cmd Markdown 编辑阅读器","date":"2016-12-12T07:16:17.000Z","path":"2016/12/12/Cmd Markdown 编辑阅读器/","text":"欢迎使用 Cmd Markdown 编辑阅读器 我们理解您需要更便捷更高效的工具记录思想，整理笔记、知识，并将其中承载的价值传播给他人，Cmd Markdown 是我们给出的答案 —— 我们为记录思想和分享知识提供更专业的工具。 您可以使用 Cmd Markdown： 整理知识，学习笔记 发布日记，杂文，所见所想 撰写发布技术文稿（代码支持） 撰写发布学术论文（LaTeX 公式支持） 除了您现在看到的这个 Cmd Markdown 在线版本，您还可以前往以下网址下载： Windows/Mac/Linux 全平台客户端 请保留此份 Cmd Markdown 的欢迎稿兼使用说明，如需撰写新稿件，点击顶部工具栏右侧的 新文稿 或者使用快捷键 Ctrl+Alt+N。 什么是 MarkdownMarkdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，粗体 或者 斜体 某些文字，更棒的是，它还可以 1. 制作一份待办事宜 Todo 列表 [ ] 支持以 PDF 格式导出文稿 [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 [x] 新增 Todo 列表功能 [x] 修复 LaTex 公式渲染问题 [x] 新增 LaTex 公式编号功能 2. 书写一个质能守恒公式[^LaTeX]$$E=mc^2$$ 3. 高亮一段代码[^code]1234567@requires_authorizationclass SomeClass: passif __name__ == '__main__': # A comment print 'hello world' 4. 高效绘制 流程图12345678st=&gt;start: Startop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 5. 高效绘制 序列图123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 6. 高效绘制 甘特图12345678910111213title 项目开发流程section 项目确定 需求分析 :a1, 2016-06-22, 3d 可行性报告 :after a1, 5d 概念验证 : 5dsection 项目实施 概要设计 :2016-07-05 , 5d 详细设计 :2016-07-08, 10d 编码 :2016-07-15, 10d 测试 :2016-07-22, 5dsection 发布验收 发布: 2d 验收: 3d 7. 绘制表格 项目 价格 数量 计算机 \\$1600 5 手机 \\$12 12 管线 \\$1 234 8. 更详细语法说明想要查看更详细的语法说明，可以参考我们准备的 Cmd Markdown 简明语法手册，进阶用户可以参考 Cmd Markdown 高阶语法手册 了解更多高级功能。 总而言之，不同于其它 所见即所得 的编辑器：你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式，省却在键盘和工具栏之间来回切换，调整内容和格式的麻烦。Markdown 在流畅的书写和印刷级的阅读体验之间找到了平衡。 目前它已经成为世界上最大的技术分享网站 GitHub 和 技术问答网站 StackOverFlow 的御用书写格式。 什么是 Cmd Markdown您可以使用很多工具书写 Markdown，但是 Cmd Markdown 是这个星球上我们已知的、最好的 Markdown 工具——没有之一 ：）因为深信文字的力量，所以我们和你一样，对流畅书写，分享思想和知识，以及阅读体验有极致的追求，我们把对于这些诉求的回应整合在 Cmd Markdown，并且一次，两次，三次，乃至无数次地提升这个工具的体验，最终将它演化成一个 编辑/发布/阅读 Markdown 的在线平台——您可以在任何地方，任何系统/设备上管理这里的文字。 1. 实时同步预览我们将 Cmd Markdown 的主界面一分为二，左边为编辑区，右边为预览区，在编辑区的操作会实时地渲染到预览区方便查看最终的版面效果，并且如果你在其中一个区拖动滚动条，我们有一个巧妙的算法把另一个区的滚动条同步到等价的位置，超酷！ 2. 编辑工具栏也许您还是一个 Markdown 语法的新手，在您完全熟悉它之前，我们在 编辑区 的顶部放置了一个如下图所示的工具栏，您可以使用鼠标在工具栏上调整格式，不过我们仍旧鼓励你使用键盘标记格式，提高书写的流畅度。 3. 编辑模式完全心无旁骛的方式编辑文字：点击 编辑工具栏 最右侧的拉伸按钮或者按下 Ctrl + M，将 Cmd Markdown 切换到独立的编辑模式，这是一个极度简洁的写作环境，所有可能会引起分心的元素都已经被挪除，超清爽！ 4. 实时的云端文稿为了保障数据安全，Cmd Markdown 会将您每一次击键的内容保存至云端，同时在 编辑工具栏 的最右侧提示 已保存 的字样。无需担心浏览器崩溃，机器掉电或者地震，海啸——在编辑的过程中随时关闭浏览器或者机器，下一次回到 Cmd Markdown 的时候继续写作。 5. 离线模式在网络环境不稳定的情况下记录文字一样很安全！在您写作的时候，如果电脑突然失去网络连接，Cmd Markdown 会智能切换至离线模式，将您后续键入的文字保存在本地，直到网络恢复再将他们传送至云端，即使在网络恢复前关闭浏览器或者电脑，一样没有问题，等到下次开启 Cmd Markdown 的时候，她会提醒您将离线保存的文字传送至云端。简而言之，我们尽最大的努力保障您文字的安全。 6. 管理工具栏为了便于管理您的文稿，在 预览区 的顶部放置了如下所示的 管理工具栏： 通过管理工具栏可以： 发布：将当前的文稿生成固定链接，在网络上发布，分享 新建：开始撰写一篇新的文稿 删除：删除当前的文稿 导出：将当前的文稿转化为 Markdown 文本或者 Html 格式，并导出到本地 列表：所有新增和过往的文稿都可以在这里查看、操作 模式：切换 普通/Vim/Emacs 编辑模式 7. 阅读工具栏 通过 预览区 右上角的 阅读工具栏，可以查看当前文稿的目录并增强阅读体验。 工具栏上的五个图标依次为： 目录：快速导航当前文稿的目录结构以跳转到感兴趣的段落 视图：互换左边编辑区和右边预览区的位置 主题：内置了黑白两种模式的主题，试试 黑色主题，超炫！ 阅读：心无旁骛的阅读模式提供超一流的阅读体验 全屏：简洁，简洁，再简洁，一个完全沉浸式的写作和阅读环境 8. 阅读模式在 阅读工具栏 点击 或者按下 Ctrl+Alt+M 随即进入独立的阅读模式界面，我们在版面渲染上的每一个细节：字体，字号，行间距，前背景色都倾注了大量的时间，努力提升阅读的体验和品质。 9. 标签、分类和搜索在编辑区任意行首位置输入以下格式的文字可以标签当前文档： 标签： 未分类 标签以后的文稿在【文件列表】（Ctrl+Alt+F）里会按照标签分类，用户可以同时使用键盘或者鼠标浏览查看，或者在【文件列表】的搜索文本框内搜索标题关键字过滤文稿，如下图所示： 10. 文稿发布和分享在您使用 Cmd Markdown 记录，创作，整理，阅读文稿的同时，我们不仅希望它是一个有力的工具，更希望您的思想和知识通过这个平台，连同优质的阅读体验，将他们分享给有相同志趣的人，进而鼓励更多的人来到这里记录分享他们的思想和知识，尝试点击 (Ctrl+Alt+P) 发布这份文档给好友吧！ 再一次感谢您花费时间阅读这份欢迎稿，点击 (Ctrl+Alt+N) 开始撰写新的文稿吧！祝您在这里记录、阅读、分享愉快！ 作者 @ghosert2016 年 07月 07日 [^LaTeX]: 支持 LaTeX 编辑显示支持，例如：$\\sum_{i=1}^n a_i=0$， 访问 MathJax 参考更多使用方法。 [^code]: 代码高亮功能支持包括 Java, Python, JavaScript 在内的，四十一种主流编程语言。","tags":[]},{"title":"Hello World","date":"2016-12-12T02:26:03.000Z","path":"2016/12/12/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post 1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]